// Load up Spacebrew
var Spacebrew = require("spacebrew");

// Load the TCP Library
net = require('net');
 
// Keep track of the clients
var clients = [];

// set port number
var port = 9001;
 
// Start a TCP Server
net.createServer(function (socket) {
 
  // Identify this client
  socket.name = socket.remoteAddress + ":" + socket.remotePort;

  // Put this new client in the list
  clients.push(socket);

  console.log('[CONN] New connection: ' + socket.name + ', total clients: ' + clients.length);
 
  // Send a nice welcome message and announce
  //socket.write("Welcome " + socket.name + "\n");
 
  // Handle incoming messages from clients.
  socket.on('data', function (data) {
    data = data.toString('utf8').trim();
    console.log('[RECV] ' + socket.name + ': ' + data);
  });

  socket.on('error', function(error) {
    if (error.code == "ECONNRESET") {
      clients.splice(clients.indexOf(socket), 1);
      console.log('[EROR] Disconnection: ' + socket.name + ', total clients: ' + clients.length)
    }
  });
 
  // Remove the client from the list when it leaves
  socket.on('end', function () {
    clients.splice(clients.indexOf(socket), 1);
    console.log('[END] Disconnection: ' + socket.name + ', total clients: ' + clients.length)
  });

 
}).listen(port);
 
console.log("[INIT] Server running on port", port);

var send = function(message) {
  console.log('[SEND] ' + message);

  if (!clients.length) return;

  for (var i = 0; i < clients.length; i++) {
  	console.log("[SEND] Checking index "+ i +" of length "+ clients.length);
    var socket = clients[i];

    socket.write(message + "\n");
  }
}


//
// Spacebrew setup for debugging
//

var server = "localhost";
var name = "loading indicator server";
var description = "";
var sb = new Spacebrew.Client(server, name, description);

// colors for loading spokes
sb.addSubscribe("rLoading", "range", "red loading");
sb.addSubscribe("gLoading", "range", "green loading");
sb.addSubscribe("bLoading", "range", "blue loading");

// colors for complete spokes
sb.addSubscribe("rComplete", "range", "red complete");
sb.addSubscribe("gComplete", "range", "green complete");
sb.addSubscribe("bComplete", "range", "blue complete");

// number of spokes lit
sb.addSubscribe("spokesLit", "range", "number of spokes lit");

var spokesLit = 0;
var rLoading = 0, gLoading = 0, bLoading = 0;
var rComplete = 0, gComplete = 0, bComplete = 0;

var onRangeMessage = function(name, value) {
  if (name == "rLoading") {
    rLoading = Math.floor(value / 4);
  }
  if (name == "gLoading") {
    gLoading = Math.floor(value / 4);
  }
  if (name == "bLoading") {
    bLoading = Math.floor(value / 4);
  }

  if (name == "rComplete") {
    rComplete = Math.floor(value / 4);
  }
  if (name == "gComplete") {
    gComplete = Math.floor(value / 4);
  }
  if (name == "bComplete") {
    bComplete = Math.floor(value / 4);
  }

  if (name == "spokesLit") {
    spokesLit = value;
  }
}

sb.onRangeMessage = onRangeMessage;

sb.connect();

var writeInterval = function() {

  // random colors
  // var r = pad(parseInt(Math.random()*55)+200, 3);
  // var g = pad(parseInt(Math.random()*55)+200, 3);
  // var b = pad(parseInt(Math.random()*55)+200, 3);

  // # of spokes lit + 1 rgb color
  // send(pad(spokesLit, 2)+","+r+","+g+","+b);

  // # of spokes lit + 2 rgb color
  // send(pad(spokesLit, 2)+","+pad(rLoading, 3)+","+pad(gLoading, 3)+","+pad(bLoading, 3)+","+pad(rComplete, 3)+","+pad(gComplete, 3)+","+pad(bComplete, 3));
  
  // only # of spokes lit + 1 rgb color
  send(pad(spokesLit, 2));

  // spokesLit = ++spokesLit % 4;

}

var pad = function(input, length, character) {
  if (!character) character = "0";

  while (input.toString().length < length) {
    input = character.toString() + input.toString();
  }
  return input;
}

// setInterval(writeInterval, 1*1000);

module.exports.send = send;